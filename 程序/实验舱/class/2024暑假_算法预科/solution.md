# DAY04

## #D、 建立信号塔

### 先考虑暴力

不难发现,在加入第 $i$ 个点时,可以暴力地扫描之前加入的 $i-1$ 个点,并求出与它们曼哈顿距离的最大值

时间复杂度 $O(n^2)$ ,可以获得 $30pts$ 

### 其次考虑特殊性质

以 $y$ 坐标相同为例(另一种情况同理),可理解为所有点都在同一条与 $x$ 轴平行的直线上

不妨将其抽象为数轴,则点 $(x,y)$ 对应数轴上的 $x$ 

现在考虑加入一个点,若加入点 $(x_i,y_i)$ ,则答案为 $\max \{abs(x_1-x_i),abs(x_2-x_i),...,abs(x_{i-1}-x_i)\}$ 

由于 $abs(a-b)=max(a-b,b-a)$ (引理1)

所以,第 $i$ 个点到第 $j$ 个点的曼哈顿距离为 $\max\{x_i-x_j,x_j-x_i\}$ 

由于对于确定的 $i$ ,$x_i$ 为定值,所以要使上式最大,有两种思路

1. 使 $-x_j$ 最大,即使 $x_j$ 最小

2. 使 $x_j$ 最大

所以不难发现对于所以 $x_j(1\leq j < i)$ ,仅最大和最小的两个有维护的必要

保存两个 $x_j$ 维护即可

### 最后考虑二维的情况

$(x_i,y_i)$ 与 $(x_j,y_j)$ 的曼哈顿距离为 $abs(x_i-x_j)+abs(y_i-y_j)$ 

由引理1,其实就是 $\max\{x_i-x_j,x_j-x_i\} + \max\{y_i-y_j,y_j-y_i\}$ 

令 $a=x_i-x_j,b=y_i-y_j$ ,则 $\max\{x_i-x_j,x_j-x_i\}$ 的结果仅有可能为 $a$ 或 $-a$ ,同理, $\max\{y_i-y_j,y_j-y_i\}$ 的结果也仅有可能为 $b$ 或 $-b$ 

则上式结果共有 $4$ 种可能: $a+b,a-b,-a+b,-a-b$ 

即分别为 $(x_i+y_i)+(-x_j-y_j),(x_i-y_i)+(-x_j+y_j),(-x_i+y_i)+(x_j-y_j),(-x_i-y_i)+(x_j+y_j)$ 

不难发现,对于确定的 $i$ ,上面式子种左括号内容中的值为定值

若想答案最大,仅需右括号内内容尽可能地大即可

所以仅需维护四个量,即对于 $1 \sim i-1$ 中的所有点, $(-x_j-y_j),(-x_j+y_j),(x_j-y_j),(x_j+y_j)$ 的最大值

每次将点与这四个点值进行运算取最大值即可

最后记得更新这四个最大值(初始时全为第一个信号塔)

#DAY05

## #A、 小明的年龄

### 思路1:计算

现在有一个 $y,m,d$ 生日的人

#### 先不考虑闰年2/29这种极特殊情况

则他在 $(y+k),m,d-1$ (即 $m,d$ 的前一天)还是 $(k-1)$ 岁

一旦到了 $(y+k),m,d$ ,他就 $k$ 岁了

所以不难发现

- 若 $M,D$ 在 $m,d$ 以前(不含),则当前年龄为 $Y-y-1$ 
- 否则年龄为 $Y-y$ 

#### 再考虑2/29

考虑如果使用上述方法,什么时候会出现反例,举出四种特殊情况

- 平年2/28生,当前为闰年2/29 $\implies$ 2/29在2/28及以后,没问题
- 平年2/28生,当前为平年2/28 $\implies$ 2/28在2/28及以后,没问题
- 闰年2/29生,当前为闰年2/29 $\implies$ 2/29在2/29及以后,没问题
- 闰年2/29生,当前为平年2/28 $\implies$ 2/28 **不** 在2/29及以后,出问题了

所以经分析,仅有闰年2/29生,现在平年2/28这一种情况会出问题

你当然可以特判解决,但是也有更简单的方法:

如果现在是 **平年的** 2/28,就把它当成2/29(注意闰年千万不能这么操作)

可以带人上面四种情况检查,发现都是没有问题的

时间复杂度 $O(1)$ 

### 思路2:二分答案

不难发现答案是 $[1,10^9]$ 之间的整数,可以二分

首先,我们可以很轻松地判断两个日期的先后顺序

一个 $y,m,d$ 生日的人,刚好 $k$ 岁时的日期为 $(y+k),m,d'$ ( **闰年2/29生日记得特判** )

若新日期 $(y+k),m,d’$ 在 $Y,M,D$ 及以前,则小明的年龄 **至少** 为 $k$ 

利用单调性二分答案解决问题,时间复杂度 $O(log10^9)\approx 30$ 



## #B、 又是九宫格键盘

首先,含有空格,只能用 `getline()` 或 `getchar()` 读取

本题其实就是打表,想要通过是很简单的,难在如何简化代码

首先,大写和空格可以特判掉,这样只用处理26个小写字母即可

当然可以用 `unordered_map` 或数组打两张表,分别存储按的按钮和次数,这样也是比较快的

但是还有更快的方法,定义一个 `string` 类型的数组 $S$ ,定义 $S_i$ 为键盘上数字 $i$ 对应的字母(如 `S[2] = "abc"` )

若 `s[i].find(ch) != s[i].npos` (注:若find找不到内容,实际上返回的不是-1,而是 字符串`.npos` ),则字符 `ch` 需要按按键 $i$ 

需要按的次数即为所找到的下标(可能需要 $+1$ ,看具体写法)

这种写法的优势在于使用了循环,这在一些题目中可以大大减少代码量,使代码逻辑更清晰



## #C、 顺路

由于在二维空间中移动,所以本质上 **最短距离即为曼哈顿距离** 

我们知道, $a,b$ 两点间曼哈顿距离为 $abs(x_a-x_b)+abs(y_a-y_b)$ 

我们首先要理解这个式子的意义是什么

不难发现,这个式子的意思是,要进行 $abs(x_a-x_b)$ 次左右移动和 $abs(y_a-y_b)$ 次上下移动

但是具体左右移动和上下移动的顺序是无所谓的(感性理解一下这句话,我们可以先向上再向右,但是我们先向右再向上也是可以的)

不难发现和修建信号塔一题很像

### 先考虑二维情况



## #D、 分类求和

不难发现 $1\sim n$ 中,不是能被 $x$ 整除的,就是不能被 $x$ 整除的 ( ~~废话~~ 

(引理)等差数列求和公式 $1+2+3+...+n=\frac{n(n+1)}{2}$ 

计 $1+2+...+n=sum_n$ ,则 $sum_n=\frac{n(n+1)}{2}$ 

则有 $g(n,x)=sum_n-f(n,x)$ 

原式

$$2\times (g(n,x)−f(n,x))=2sum_n-4f(n,x)=n(n+1)-4f(n,x)$$ 

考虑求 $f(n,x)$ ,因为 $1\sim n$ 中有 $\lfloor \frac{n}{x} \rfloor$ 个 $x$ 的整倍数

记 $k=\lfloor \frac{n}{x} \rfloor$ ,则 

$$f(n,x)=x+2x+...+kx=x(1+2+...+k)=\frac{k(k+1)}{2}x$$ 

原式

$$n(n+1)-4f(n,x)=n(n+1)-4\frac{k(k+1)}{2}x=n(n+1)-2k(k+1)x$$ 

由于 $n,x\leq 10^{18}$ ,考虑如何对 $mod$ 取模

由于 **除法不可简单取模** ,所以要先算出 $k$ ,再进行下一步操作(当然,该操作等价于在模意义下乘上 $x^{mod-2} \%mod$ ,可以用逆元解决)

其次应对 $n,k$ 对 $mod$ 取模

接下来按式子操作,每一次乘操作后要取模,减操作要减数与被减数 **分别取模** 后再加一倍模数后取模

# DAY06

## #A、 闰年产生的原因

令 $curh,curm,curs$ 分别表示 小时,分钟,秒钟 产生的误差

考虑第 $m$ 年

### 每年误差

每一年会导致误差增加 $5h,48min,46s$ 

共有 $m$ 次这样的误差

```cpp
curh += m * 5;
curm += m * 48;
curs += m * 46;
```

### 每四年误差

每四年润一年,使误差减少 $24h$ 

但是注意润的年也有 $5h,48min,46s$ 误差

所以不需要画蛇添足减掉

共有 $\lfloor \frac{m}{4} \rfloor$ 次这样的误差

### 每一百年误差

每100年不润,由于上述操作每100年也润了

所以每100年误差增加 $24h$ 即可,相当于撤销闰年

共有 $\lfloor \frac{m}{100} \rfloor$ 次这样的误差

### 每四百年误差

每400年再润,由于上述操作,我们将400年的闰年撤销了

所以每400年误差减小 $24h$ ,相当于再加上闰年

共有 $\lfloor \frac{m}{400} \rfloor$ 次这样的误差

### 注意处理后输出

注意 $0\leq curs,curm\lt 60$ 

所以 $curs$ 先向 $curm$ 进位, $curm$ 再向 $curh$ 进位

不难发现 $curs,curm$ 必为非负数,题目就是诈骗



## #B、 大分数比较

作差法:对于两式 $A,B$ ,有

- $A-B > 0\implies A>B$ 

- $A-B=0\implies A=B$

- $A-B\lt 0\implies A\lt B$

显然有 $\dfrac{x}{a}-\dfrac{y}{b}=\dfrac{bx-ay}{ab}$ 

由于 $ab$ 必为正数, $bx-ay$ 的正负性即为 $\dfrac{x}{a}-\dfrac{y}{b}$ 的正负性

查看 $bx-ay$ 正负性即可

但是 $bx-ay$ 最坏情况下可到 $10^{27}$ ,long long无法储存

### 方法1:__int128秒掉

__int128 是 C++ 的一种数据类型,可储存大约到 $10^{35}$ 的整数

**现在 __int128 允许在 CCF 系列赛事中使用** 

以下为 CCF 在 2024联合省选 中给出的 __int128 标准 IO(输入输出) 板子

```cpp
void read(__int128 &x){
    // read a __int128 variable
    char c; bool f = 0;
    while(((c = getchar()) < '0' || c > '9') && c != '-');
    if(c == '-'){f = 1; c = getchar();}
    x = c - '0';
    while((c = getchar()) >= '0' && c <= '9')x = x * 10 + c - '0';
    if(f) x = -x;
}

void write(__int128 x){
    // print a __int128 variable
    if(x < 0){putchar('-'); x = -x;}
    if(x > 9)write(x / 10);
    putchar(x % 10 + '0');
}
```

有了数据类型的加持,其他都不是难事

### 方法2:转换成带分数运算

注意到 $a,b\leq 10^9$ ,这是本题的突破口

不难将 $\dfrac{n}{m}$ 写为 $(\lfloor \dfrac{n}{m} \rfloor)\dfrac{n\%m}{m}$ 的带分数形式

同理, $\dfrac{x}{a}=(\lfloor \dfrac{x}{a} \rfloor)\dfrac{x\%a}{a},\dfrac{y}{b}=(\lfloor \dfrac{y}{b} \rfloor)\dfrac{y\%b}{b}$ 

优先比较 $\lfloor \dfrac{x}{a} \rfloor$ 与 $\lfloor \dfrac{y}{b} \rfloor$ 的大小关系,能比较出则直接得出答案

否则则比较 $\dfrac{x\%a}{a}$ 和 $\dfrac{y\%b}{b}$ 的关系

不难发现 $(x\%a),(y\%b),a,b\leq 10^9$ ,作差法利用long long存储比较即可



## #C、 击杀怪兽

考虑一只目前高度为 $h$ 的怪兽,写成 $h=pk+q(p,q\in \N,1\leq q\leq k)$ 的形式

**请务必注意上式和带余除法不完全相同** ,如 $h=5,k=5$ ,则 $h=0k+5$ 

若 $p=0$ ,则不难发现受到一次攻击后即死亡

否则,受到一次攻击后,血量变为 $h'=(p-1)k+q$ ,不难发现 $h \equiv h'\equiv q(mod\ k)$ 

即怪兽受到一次攻击后,其血量 $mod\ k$ 的结果不变,皆为 $q$ 

若原来有 $n$ 只怪兽,血量分别为 $h_1=p_1k+q_1,h_2=p_2k+q_2,...,h_n=p_nk+q_n(1\leq q_1,q_2,...,q_n\leq k)$ 

不难发现对于 $i,j$ 而言,若 $p_i > p_j$ ,无论 $q_i,q_j$ 大小关系则当前情况下 $i$ 必然比 $j$ 先受到攻击

所以必有一时刻,满足 **所有怪物都存活** ,且 $p_1=p_2=...=p_n=0$ 

即

$$h_1’=q_1,h_2'=q_2,...,h_n'=q_n$$ 

由于 $1\leq q_1,q_2,...,q_n\leq k$ ,所以当前所有怪物必将被 **一击必杀** 

Mas的攻击顺序即为怪物死亡顺序,Mas将先按生命值( $h_i’$ )攻击,相同时按编号攻击

使用结构体的多关键字排序即可,时间复杂度 $O(nlogn)$ 

**千万注意** ,由于 $1\leq q_1,q_2,...,q_n\leq k$ ,所以若 $h_i\ mod\ k=0$ ,实际上 $q_i=k$ 



## #D、 又是田忌赛马

前 $20pts$ 纯靠判断解决问题

如果你会搜索,那么 $40pts$ 是很好拿的

### 其次考虑可被优化的通解

为了利用单调性解决问题,不妨让田忌和齐威王的马都由速度值由小到大排序

计田忌的马的速度值为 $a_1,a_2,...,a_n$ ,齐威王马的速度值为 $b_1,b_2,...,b_n$ 

现在考虑田忌的每只马能产生的贡献,显然,该贡献不是 $1$ (打赢了齐威王的某只马)就是 $0$ (没有马让他打败了)

我们从前至后地考虑田忌的 $n$ 只马,若当前考虑到第 $i$ 只,齐威王未应战的马的集合为 $T$ 

首先尝试寻找 $T$ 中 **最大的** $\lt a_i$ 的元素 $b_j$ ,让 $a_i$ 去击败 $b_j$ 即可

不难发现,对于任何 $k$ 满足 $b_k\leq b_j$ ,交换 $b_k,b_j$ ,局面一定不可能变得更优

当然,该操作最多只可能让将来田忌的一只马有可能找不到能击败的对手,产生的贡献由 $1$ 变为 $0$ ,但是由于这只马 $a_i$ 已经产生了 $1$ 的贡献,所以可证明让 $a_i$ 击败 $b_j$ 一定最优

若无法在 $T$ 中找到合适的元素,说明这只马已经不可能产生 $1$ 的贡献,即对结果无影响,直接跳过即可

直至将 $a$ 数组遍历完毕,检查田忌所有马一共产生了多少贡献,即为可能的最大分数

若考虑最小分数,我们可以将 **齐威王与田忌交换** ,此时即求齐威王的马最多能产生多少贡献

**注意** ,由于我们反着思考,所以双方平局的情况,对于齐威王的马是会产生为 $1$ 的贡献的(即我们在 $T$ 中寻找的是最大的 $\leq b_i$ 的元素,此处取等)

最终用 $n$ 减去齐威王的马产生的最大贡献,即为可能的最小分数

不难发现这种算法的时间复杂度主要依赖于在 $T$ 中寻找元素的时间复杂度,若这一步时间复杂度为 $O(g(n))$ ,则总时间复杂度为 $O(ng(n))$ 

不难发现若对于每一次都把 $T$ 暴力扫一遍, $g(n)=n$ ,总时间复杂度 $O(n^2)$ ,可拿到 $70pts$ 

#### 优化思路1:数据结构优化

不难发现我们是在 $T$ 中寻找第一个 $\lt$ 或 $\leq$ 定值的元素

考虑维护单调性后二分,但是由于 $T$ 会有删除操作,所以考虑使用 set 维护

若 set 名为 s

使用 `s.lower_bound(val)` 可寻找第一个 $\geq val$ 的元素 **位置** ,返回迭代器,向前寻找一个即为最大的 $\lt val$ 的元素位置

使用 `s.upper_bound(val)` 可寻找第一个 $> val$ 的元素 **位置** ,返回迭代器,向前寻找一个即为最大的 $\leq val$ 的元素位置

$g(n)=logn$ ,总时间复杂度 $O(nlogn)$ ,可以通过

#### 优化思路2:双指针优化

由大至小考虑 $a$ 数组,即从 $a_n$ 至 $a_1$ 遍历 $a$ 

同理,由大到小考虑 $b$ 

假如某一时刻考虑 $a_l$ 和 $b_r$ ,初始时 $l=r=n$ 

**以考虑田忌的最优解为例,若考虑齐威王,将下列各个大于,小于号与大于等于,小于等于号互换即可** 

若 $a_l\leq b_r$ ,由于 $a$ 数组有序,必有 $a_1\leq a_2\leq ... \leq a_l\leq b_r\leq b_{r+1}\leq..\leq b_n$ 

不难发现对于 $i\in [1,l)$ ,考虑 $b_r$ 及 $b_r$ 以后的马无意义

此时 $r--$ ,对于田忌而言没有贡献产生

否则, 此时的 $b_r$ 必为最大的 $\lt a_l$ 的元素(用反证法不难证明)

$l--,r--$ ,完成一次赛马,田忌的马增加了 $1$ 的贡献

若 $l\lt 1 \or r\lt 1$ ,则遍历结束,统计贡献即可

由于平均下来每个数组元素只访问一次,均摊时间复杂度 $g(n)=1$ ,总时间复杂度 $O(n)$ ,可以通过

# DAY09

## #A、 三维表面积

以 $1\times 1$ 的格子为例,我们研究表面积从何而来

- 上面与下面
- 四周:四周的高度为 $0$ ,所以若这一叠正方体高度为 $h$ ,则它在四周的每个面都能贡献 $h$ 的表面积
