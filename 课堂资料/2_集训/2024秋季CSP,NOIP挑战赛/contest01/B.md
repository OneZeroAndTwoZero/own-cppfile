考虑倒着枚举操作序列，其中 $[r_i+1,r_i+1+(r_i-l_i)]$ 是由 $[l_i,r_i]$ 复制过来的，对于这部分字符我们只需要按顺序枚举它是有哪个字符复制过来的即可，用 $fa_i$ 来存储字符 $i$ 是由原先的哪个字符复制过来的。

显然只需要考虑最终位置编号 $\le r$ 的字符即可，设 $now$ 为当前最终位置编号 $\le r$ 的字符还剩下多少，每次解决掉一个字符是从哪里复制的就将 $now$ 减一，当 $now\le r_i$ 时说明当前处理的字符的最终编号 $>r$，并不在我们输出的范围之内，无需再探究它是由谁复制而来的了。

快速维护每个字符所代表的编号可以用树状数组维护，查询一个当前编号所对应的最终编号可以用树状数组上二分解决。

然后根据 $fa_i$ 和原字符串 $s$ 推出新的答案字符串即可。

时间复杂度：$O(n\log n+q)$，常数很小。